package org.codemucker.jmutate.generate;

import java.lang.annotation.Annotation;

import org.codemucker.jmutate.JMutateContext;
import org.codemucker.jmutate.SourceTemplate;
import org.codemucker.jmutate.ast.JField;
import org.codemucker.jmutate.ast.JMethod;
import org.codemucker.jmutate.ast.JSourceFile;
import org.codemucker.jmutate.ast.JType;
import org.codemucker.jmutate.transform.CleanImportsTransform;
import org.codemucker.jmutate.transform.InsertFieldTransform;
import org.codemucker.jmutate.transform.InsertMethodTransform;
import org.codemucker.jpattern.generate.ClashStrategy;
import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.jdt.core.dom.FieldDeclaration;
import org.eclipse.jdt.core.dom.MethodDeclaration;

public abstract class AbstractGenerator<T extends Annotation> implements CodeGenerator<T> {
	
	private final JMutateContext ctxt;
	private final CodeGenMetaGenerator generatorMeta;
	private ReplaceOnlyOwnedNodesResolver nodeClashResolver;
	
	public AbstractGenerator(JMutateContext ctxt){
		this.ctxt = ctxt;
		this.generatorMeta = new CodeGenMetaGenerator(ctxt, getClass());
		setClashStrategy(ClashStrategy.SKIP);
	}
	
	@Override
	public final void generate(ASTNode declaredInNode, SmartConfig config) {
		if (JType.is(declaredInNode)) {
			generate(JType.from(declaredInNode), config);
		} else if (JField.is(declaredInNode)) {
			generate(JField.from(declaredInNode), config);
		} else if (JMethod.is(declaredInNode)) {
			generate(JMethod.from(declaredInNode), config);
		}
	}

	protected void generate(JType declaredInNode, SmartConfig config) {}

	protected void generate(JMethod declaredInNode, SmartConfig config) {}

	protected void generate(JField declaredInNode, SmartConfig config) {}

	
	@Override
	public void beforeRun() {
		//TODO:find all artifacts generated by this generator
	}

	@Override
	public void afterRun() {
		//TODO:remove all artifacts belonging to this generator which were not regenerated
	}
	
	protected void setClashStrategy(ClashStrategy clashDefaultStrategy){
		this.nodeClashResolver = new ReplaceOnlyOwnedNodesResolver(generatorMeta,clashDefaultStrategy);		
	}

	protected void addField(JType type, FieldDeclaration f, boolean markGenerated) {
		if(markGenerated){
			getGeneratorMeta().addGeneratedMarkers(f);
		}
		ctxt.obtain(InsertFieldTransform.class)
				.clashStrategy(nodeClashResolver)
				.target(type)
				.field(f)
				.transform();
		
	}
	
	protected void addMethod(JType type, MethodDeclaration m, boolean markGenerated) {
		if(markGenerated){
			getGeneratorMeta().addGeneratedMarkers(m);
		}
		ctxt.obtain(InsertMethodTransform.class)
				.clashStrategy(nodeClashResolver)
				.target(type)
				.method(m)
				.transform();
		
	}

	protected void writeToDiskIfChanged(JSourceFile source) {
		if (source != null) {
			cleanupImports(source.getAstNode());
			source = source.asMutator(ctxt).writeModificationsToDisk();
		}
	}

	protected void cleanupImports(ASTNode node) {
		ctxt.obtain(CleanImportsTransform.class).addMissingImports(true)
				.nodeToClean(node).transform();
	}
	
	protected SourceTemplate newSourceTemplate(){
		return ctxt
			.newSourceTemplate();
	}

	protected JMutateContext getContext(){
		return ctxt;
	}

	public CodeGenMetaGenerator getGeneratorMeta() {
		return generatorMeta;
	}

}