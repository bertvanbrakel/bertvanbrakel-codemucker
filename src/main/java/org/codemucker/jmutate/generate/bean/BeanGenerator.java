package org.codemucker.jmutate.generate.bean;

import org.apache.log4j.LogManager;
import org.apache.log4j.Logger;
import org.codemucker.jmatch.AString;
import org.codemucker.jmatch.Matcher;
import org.codemucker.jmatch.expression.ExpressionParser;
import org.codemucker.jmatch.expression.StringMatcherBuilderCallback;
import org.codemucker.jmutate.ClashStrategyResolver;
import org.codemucker.jmutate.JMutateContext;
import org.codemucker.jmutate.JMutateException;
import org.codemucker.jmutate.SourceTemplate;
import org.codemucker.jmutate.ast.JField;
import org.codemucker.jmutate.ast.JMethod;
import org.codemucker.jmutate.ast.JSourceFile;
import org.codemucker.jmutate.ast.JType;
import org.codemucker.jmutate.ast.matcher.AJField;
import org.codemucker.jmutate.generate.AbstractCodeGenerator;
import org.codemucker.jmutate.generate.CodeGenMetaGenerator;
import org.codemucker.jmutate.generate.GeneratorConfig;
import org.codemucker.jmutate.generate.pojo.PojoModel;
import org.codemucker.jmutate.generate.pojo.PojoProperty;
import org.codemucker.jmutate.generate.pojo.PropertiesExtractor;
import org.codemucker.jmutate.transform.CleanImportsTransform;
import org.codemucker.jmutate.transform.InsertFieldTransform;
import org.codemucker.jmutate.transform.InsertMethodTransform;
import org.codemucker.jpattern.bean.NotAProperty;
import org.codemucker.jpattern.bean.Property;
import org.codemucker.jpattern.generate.ClashStrategy;
import org.codemucker.jpattern.generate.GenerateBean;
import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.jdt.core.dom.FieldDeclaration;
import org.eclipse.jdt.core.dom.MethodDeclaration;

import com.google.common.base.Strings;
import com.google.inject.Inject;

/**
 * Generates property getters/setters for a bean, along with various bean
 * bindings if required
 */
public class BeanGenerator extends AbstractCodeGenerator<GenerateBean> {

	private static final Logger LOG = LogManager.getLogger(BeanGenerator.class);

	/**
	 * Used to select a reproducible starting prime when generating a hash code. Rather than pick a random one at each generation causing churn in the code, pick out of this array in a deterministic way based
	 * on bean name
	 */
	private static final int[] FIRST_PRIMES = new int[]{31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997,1009,1013};
	
	private final CodeGenMetaGenerator generatorMeta;

	private final JMutateContext ctxt;
	private ClashStrategyResolver methodClashResolver;

	@Inject
	public BeanGenerator(JMutateContext ctxt) {
		this.ctxt = ctxt;
		this.generatorMeta = new CodeGenMetaGenerator(ctxt, getClass());
	}

	
	@Override
	public void beforeRun() {
		//TODO:find all artifacts generated by this generator
	}


	@Override
	public void afterRun() {
		//TODO:remove all artifacts belonging to this generator which were not regenerated
	}

	@Override
	public void generate(JType optionsDeclaredInNode, GeneratorConfig options) {
		if(optionsDeclaredInNode.isInterface()){
			LOG.warn("the " + GenerateBean.class.getName() + " generation annotation on an interface is not supported");
			return;
		}
		BeanModel model = new BeanModel(optionsDeclaredInNode,options);
		ClashStrategy methodClashDefaultStrategy = model.options.getClashStrategy();
		methodClashResolver = new OnlyReplaceMyManagedMethodsResolver(methodClashDefaultStrategy);
		
		extractAllProperties(optionsDeclaredInNode, model);
		
		LOG.debug("found " + model.getProperties().size() + " bean properties for "  + model.options.getType().getFullNameRaw());
		generateBeanProperties(optionsDeclaredInNode, model);
	}
	
	private void extractAllProperties(JType optionsDeclaredInNode,BeanModel model) {
		
		LOG.debug("adding properties to " + model.options.getType().getFullName());
		
		Matcher<String> fieldMatcher = fieldMatcher(model.options.getFieldNames());
		
		PropertiesExtractor extractor = PropertiesExtractor.with(ctxt.getResourceLoader(), ctxt.getParser())
			.includeCompiledClasses(true)
			.propertyNameMatcher(fieldMatcher)
			.includeSuperClass(model.options.isInheritSuperClassProperties())
			.build();
		
		PojoModel pojo = extractor.extractProperties(optionsDeclaredInNode);
		
		boolean fromSuper = false;
		while(pojo !=null){	
			for(PojoProperty p:pojo.getDeclaredProperties()){
				boolean readonly = model.options.isMakeReadonly() || p.isFinalField();
				BeanPropertyModel p2 = new BeanPropertyModel(model, p, !readonly, true, model.options.isBindable(), model.options.isVetoable(), fromSuper);
				model.addProperty(p2);
			}
			pojo = pojo.getParent();
			fromSuper = true;
		}
	}

	private Matcher<String> fieldMatcher(String s){
		if(Strings.isNullOrEmpty(s)){
			return AString.equalToAnything();
		}
		return ExpressionParser.parse(s, new StringMatcherBuilderCallback());
	}

	private void generateBeanProperties(JType bean,BeanModel model) {
		JSourceFile source = bean.getSource();
		
		generateNoArgCtor(bean, model);
		generateAllArgCtor(bean, model);
		generateStaticPropertyNames(bean, model);
		
		for (BeanPropertyModel property : model.getProperties().values()) {
			generateFieldAccess(bean, model, property);			
			generateGetter(bean, model, property);
			generateSetter(bean, model, property);
			generateCollectionAddRemove(bean, model, property);
			generateMapAddRemove(bean, model, property);
		}
		
		generatePropertyChangeSupport(bean, model);
		generateVetoableChangeSupport(bean, model);
		
		generateToString(bean, model);
		generateEquals(bean, model);
		generateHashCode(bean, model);
		generateClone(bean, model);
		
		writeToDiskIfChanged(source);
	}

	private void generateNoArgCtor(JType bean, BeanModel model) {
		if(model.options.isGenerateNoArgCtor() && !model.hasDirectFinalProperties()){
			
			JMethod ctor = ctxt
				.newSourceTemplate()
				.pl("public " + model.options.getType().getSimpleNameRaw() + "(){}")
				.asConstructorSnippet();
			addMethod(bean, ctor.getAstNode(), model.options.isMarkGenerated());
		}
	}
	
	private void generateAllArgCtor(JType beanType, BeanModel model) {
		if(model.options.isGenerateAllArgCtor()){
			SourceTemplate beanCtor = ctxt
					.newSourceTemplate()
					.var("b.name", model.options.getType().getSimpleNameRaw())
					.pl("private ${b.name} (");
			
			boolean comma = false;
			//args
			for (BeanPropertyModel property : model.getFields()) {
				if(comma){
					beanCtor.p(",");
				}
				if(model.options.isMarkCtorArgsAsProperties()){
					beanCtor.p("@" + Property.class.getName() + "(name=\"" + property.getPropertyName() + "\") ");
				}
				beanCtor.p(property.getType().getFullName() + " " + property.getPropertyName());
				comma = true;
			}
			
			beanCtor.pl("){");
			//field assignments
			for (BeanPropertyModel property : model.getFields()) {
				if(property.isFromSuperClass()){
					beanCtor.pl(property.getPropertySetterName() + "(" + property.getPropertyName() + ");");
				} else {
					beanCtor.pl("this." + property.getPropertyName() + "=" + property.getPropertyName() + ";");
				}
			}
			beanCtor.pl("}");
			addMethod(beanType, beanCtor.asConstructorNodeSnippet(),model.options.isMarkGenerated());
		}
	}

	private void generateStaticPropertyNames(JType bean, BeanModel model) {
		//static property names
		if(model.options.isGenerateStaticPropertyNameFields()){
			for (BeanPropertyModel property : model.getProperties().values()) {
				JField staticField = ctxt
					.newSourceTemplate()
					.pl("public static final String PROP_" + property.getPropertyName().toUpperCase() + " = \"" + property.getPropertyName() +"\";")
					.asJFieldSnippet();
				addField(bean, staticField.getAstNode(), model.options.isMarkGenerated());
			}	
		}
	}

	private void generateClone(JType bean, BeanModel model) {
		if(model.options.isGenerateCloneMethod() && !bean.isAbstract()){
			LOG.debug("adding method 'newInstanceOf'");

			SourceTemplate clone = ctxt
				.newSourceTemplate()
				.var("b.type", model.options.getType().getSimpleName())
				.var("b.genericPart", model.options.getType().getGenericPartOrEmpty())
				.var("b.typeBounds", model.options.getType().getTypeBoundsOrEmpty())
				
				
				.pl("public static ${b.typeBounds} ${b.type} newInstanceOf(${b.type} bean){")
				.pl("if(bean == null){ return null;}")
				.pl("final ${b.type} clone = new ${b.type}();");
			
			for (BeanPropertyModel property : model.getProperties().values()) {
				SourceTemplate t = clone
					.child()
					.var("p.name",property.getPropertyName())
					.var("p.getter",property.getPropertyGetterName())
					.var("p.setter",property.getPropertySetterName())
					.var("p.type",property.getType().getFullName())
					.var("p.concreteType",property.getPropertyConcreteType())
					.var("p.rawType",property.getType().getFullNameRaw())
					.var("p.genericPart",property.getType().getGenericPartOrEmpty())
					
					;
				if(property.getType().isPrimitive()){
					if(property.isFromSuperClass()){
						t.pl("	clone.${p.setter}(bean.${p.getter}());");			
					} else {
						t.pl("	clone.${p.name} = bean.${p.name};");
					}
				} else if(property.getType().isArray()){
					if(property.isFromSuperClass()){
						t.pl("	if(bean.${p.getter}() == null){");
						t.pl("		clone.${p.setter}(null);");
						t.pl("	} else {");
						t.pl("		${p.rawType}[] src = bean.${p.getter}();");
						t.pl("		${p.rawType}[] copy = new ${p.rawType}[src.length];");
						t.pl("		System.arraycopy(src,0,copy,0,src.length);");
						t.pl("		clone.${p.setter}(copy);");
						t.pl("	}");
						
					} else {
						t.pl("	if(bean.${p.name} == null){");
						t.pl("		clone.${p.name} = null;");
						t.pl("	} else {");
						t.pl("		clone.${p.name} = new ${p.rawType}[bean.${p.name}.length];");
						t.pl("		System.arraycopy(bean.${p.name},0,clone.${p.name},0,bean.${p.name}.length);");
						t.pl("	}");
					}
				} else if(property.getType().isIndexed()){
					if(property.isFromSuperClass()){
						//TODO:add a safe copy util in here. codemucker.lang?
						t.pl("	clone.${p.setter}(bean.${p.getter}()} == null?null:new ${p.concreteType}${p.genericPart}(bean.${p.getter}());");
					} else {
						t.pl("	clone.${p.name} = bean.${p.name} == null?null:new ${p.concreteType}${p.genericPart}(bean.${p.name});");
					}
				} else {
			//		if(hasClassGotMethod(property.propertyTypeRaw, AString.matchingAntPattern("*newInstanceOf"))){
					//	t.pl("	clone.${p.name} = bean.${p.name} == null?null:${p.rawType}.newInstanceOf(bean.${p.name});");
				//	} else {
					if(property.isFromSuperClass()){
						t.pl("	clone.${p.setter}(bean.${p.getter}());");
					} else {
						t.pl("	clone.${p.name} = bean.${p.name};");
					}
					//}
				}
						
				clone.add(t);
			}
			clone.pl("return clone;");
		
			clone.pl("}");
			
			addMethod(bean, clone.asMethodNodeSnippet(),model.options.isMarkGenerated());
		}
	}

	private void generateHashCode(JType bean, BeanModel model) {
		if(model.options.isGenerateHashCodeEquals() && !model.getProperties().isEmpty()){
			int startingPrime = pickStartingPrimeForClass(model.options.getType().getFullName());
			SourceTemplate hashcode = ctxt
				.newSourceTemplate()
				.var("prime", startingPrime)
				.pl("@java.lang.Override")
				.pl("public int hashCode(){");
				
			if(model.getProperties().isEmpty()){
				hashcode.pl("return super.hashCode();");
			} else {
				hashcode.pl("final int prime = ${prime};");
				hashcode.pl("int result = super.hashCode();");
				for (BeanPropertyModel property : model.getProperties().values()) {
					SourceTemplate t = hashcode
						.child()
						.var("p.accessor",property.isFromSuperClass()?(property.getPropertyGetterName() + "()"):property.getPropertyName());
					
					if(property.getType().isPrimitive() && !property.getType().isString()){
						//from the book 'Effective Java'
						if(property.getType().is("boolean")){
							t.pl("result = prime * result + (${p.accessor} ? 1:0);");
						} else if(property.getType().is("byte") || property.getType().is("char") || property.getType().is("int")){
							t.pl("result = prime * result + ${p.accessor};");
						} else if(property.getType().is("long")){
							t.pl("result = prime * result + (int) (${p.accessor} ^ (${p.accessor} >>> 32));");
						} else if(property.getType().is("float")){
							t.pl("result = prime * result + java.lang.Float.floatToIntBits(${p.accessor});");
						} else if(property.getType().is("double")){
							t.pl("result = prime * result + java.lang.Double.doubleToLongBits(${p.accessor});");
						} else  {
							t.pl("result = prime * result + ${p.accessor}.hashCode();");			
						}
					} else {
						t.pl("result = prime * result + ((${p.accessor} == null) ? 0 : ${p.accessor}.hashCode());");
					}
					hashcode.add(t);
				}
				hashcode.pl("return result;");
			}
			
			hashcode.pl("}");
			
			addMethod(bean, hashcode.asMethodNodeSnippet(),model.options.isMarkGenerated());
		}
	}

	private void generatePropertyChangeSupport(JType bean, BeanModel model) {
		if(model.options.isBindable()){
			//TODO:check parent beans for existing property support
			SourceTemplate t = ctxt
				.newSourceTemplate()
				.var("change.name", model.options.getPropertyChangeSupportFieldName());
		
			SourceTemplate changeSupportField = t.child()
				.pl("@" + NotAProperty.class.getName())
				.pl("private final java.beans.PropertyChangeSupport ${change.name} = new java.beans.PropertyChangeSupport(this);");
		
			SourceTemplate addListener = t.child()
				.pl("public void addPropertyChangeListener(java.beans.PropertyChangeListener listener){")
				.pl("	this.${change.name}.addPropertyChangeListener(listener);")
				.pl("}");
		
			SourceTemplate addNamedListener = t.child()
				.pl("public void addPropertyChangeListener(String propertyName,java.beans.PropertyChangeListener listener){")
				.pl("	this.${change.name}.addPropertyChangeListener(propertyName,listener);")
				.pl("}");
			
			SourceTemplate removeListener = t.child()
				.pl("public void removePropertyChangeListener(java.beans.PropertyChangeListener listener){")
				.pl("	this.${change.name}.removePropertyChangeListener(listener);")
				.pl("}");

			addField(bean, changeSupportField.asFieldNodeSnippet(), model.options.isMarkGenerated());
			addMethod(bean, addListener.asMethodNodeSnippet(),model.options.isMarkGenerated());
			addMethod(bean, addNamedListener.asMethodNodeSnippet(),model.options.isMarkGenerated());
			addMethod(bean, removeListener.asMethodNodeSnippet(),model.options.isMarkGenerated());
		}
	}

	private void generateVetoableChangeSupport(JType bean, BeanModel model) {
		if(model.options.isVetoable()){
			//TODO:check parent beans for existing property support
			SourceTemplate t = ctxt.newSourceTemplate()
				.var("veto.name", model.options.getVetoableChangeSupportFieldName());
		
			SourceTemplate changeSupportField = t.child()
				.pl("@" + NotAProperty.class.getName())
				.pl("private final java.beans.VetoableChangeSupport ${veto.name} = new java.beans.VetoableChangeSupport(this);");
		
			SourceTemplate addListener = t.child()
				.pl("public void addVetoableChangeListener(java.beans.VetoableChangeListener listener){")
				.pl("	this.${veto.name}.addVetoableChangeListener(listener);")
				.pl("}");
		
			SourceTemplate addNamedListener = t.child()
				.pl("public void addVetoableChangeListener(String propertyName, java.beans.VetoableChangeListener listener){")
				.pl("	this.${veto.name}.addVetoableChangeListener(propertyName,listener);")
				.pl("}");
			
			SourceTemplate removeListener = t.child()
				.pl("public void removeVetoableChangeListener(java.beans.VetoableChangeListener listener){")
				.pl("	this.${veto.name}.removeVetoableChangeListener(listener);")
				.pl("}");

			addField(bean, changeSupportField.asFieldNodeSnippet(), model.options.isMarkGenerated());
			addMethod(bean, addListener.asMethodNodeSnippet(),model.options.isMarkGenerated());
			addMethod(bean, addNamedListener.asMethodNodeSnippet(),model.options.isMarkGenerated());
			addMethod(bean, removeListener.asMethodNodeSnippet(),model.options.isMarkGenerated());
		}
	}

	
	private void generateEquals(JType bean, BeanModel model) {
		if(model.options.isGenerateHashCodeEquals() && !model.getProperties().isEmpty()){
			
			SourceTemplate equals = ctxt
					.newSourceTemplate()
					.var("b.type", model.options.getType().getSimpleName())
					.pl("@java.lang.Override")
					.pl("public boolean equals(final Object obj){")
					.pl("if (this == obj) return true;")
					.pl("if (!super.equals(obj) || getClass() != obj.getClass()) return false;");
			
			if(!model.getProperties().isEmpty()){
				equals.pl("${b.type} other = (${b.type}) obj;");
				for (BeanPropertyModel property : model.getProperties().values()) {
					SourceTemplate  t = equals
						.child()
						.var("p.accessor",property.isFromSuperClass()?(property.getPropertyGetterName() + "()"):property.getPropertyName());
					
					if(property.getType().isPrimitive() && !property.getType().isString()){
						t.pl("if (${p.accessor} != other.${p.accessor}) return false;");
					} else {
						t.pl("if(${p.accessor} == null) {")
						.pl("	if (other.${p.accessor} != null)")
						.pl("		return false;")
						.pl("} else if (!${p.accessor}.equals(other.${p.accessor}))")
						.pl("	return false;");
					}
					equals.add(t);
				}
			}
			equals.pl("	return true;");
			equals.pl("}");
			

			addMethod(bean, equals.asMethodNodeSnippet(),model.options.isMarkGenerated());
		}
	}

	private void generateToString(JType bean, BeanModel model) {
		if(model.options.isGenerateToString()){
			StringBuilder sb = new StringBuilder();
//			String label = model.type.simpleNameRaw;
//			JType t = bean;
//			while(!t.isTopLevelClass()){
//				t = t.getParentJType();
//				label = t.getSimpleName() + "." + label;
//			}
			sb.append("\" [");
			if(model.getProperties().isEmpty()){
				sb.append("]\"");
			} else {
				boolean comma = false;
				for (BeanPropertyModel property : model.getProperties().values()) {
					if(comma){
						sb.append(" + \",");
					}
					sb.append(property.getPropertyName() ).append("=\" + ");
					if(property.isFromSuperClass()){
						sb.append(property.getPropertyGetterName()).append("()");
					} else {
						sb.append(property.getPropertyName());
					}
					comma = true;
				}
				sb.append(" + \"]\"");
			}
			
			SourceTemplate toString = ctxt
				.newSourceTemplate()
				.pl("@java.lang.Override")
				.pl("public String toString(){")
				.pl("return this.getClass().getName() + \"@\" + System.identityHashCode(this) + " + sb.toString() + ";")
				.pl("}");
			addMethod(bean, toString.asMethodNodeSnippet(),model.options.isMarkGenerated());
		}
	}

	private void generateFieldAccess(JType bean, BeanModel model,BeanPropertyModel property) {
		if(property.isFromSuperClass()){
			return;
		}
		JField field = bean.findFieldsMatching(AJField.with().name(property.getPropertyName())).getFirst();
		if(!field.getAccess().equals(model.options.getFieldAccess())){
			field.getJModifiers().setAccess(model.options.getFieldAccess());
		}
	}

	private void generateSetter(JType bean, BeanModel model,BeanPropertyModel property) {
		//setter
		if(!property.isFromSuperClass() && property.getPropertySetterName() != null && property.isGenerateSetter()){
			SourceTemplate setter = ctxt
				.newSourceTemplate()
				.var("p.name", property.getPropertyName())
				.var("p.setterName", property.getPropertySetterName())
				.var("p.type", property.getType().getObjectTypeFullName())
				.var("support.bind.name", model.options.getPropertyChangeSupportFieldName())
				.var("support.veto.name", model.options.getVetoableChangeSupportFieldName())
				
				.p("public void ${p.setterName}(final ${p.type} val)");
			
				if(property.isVetoable()){
					setter.p(" throws java.beans.PropertyVetoException ");
				}
				setter.pl("{");
				CharSequence vetoString = "";
				
				if(property.isVetoable()){
					vetoString = setter.child()
					.pl("   this.${support.veto.name}.fireVetoableChange(\"${p.name}\",this.${p.name},val);")
					.interpolateTemplate();
				}
				if(property.isBindable()){
					setter
						.pl("	${p.type} oldVal = this.${p.name};")
						.p(vetoString)
						.pl("	this.${p.name} = val;")
						.pl("   this.${support.bind.name}.firePropertyChange(\"${p.name}\",oldVal,val);");
				} else {
					setter
						.p(vetoString)
						.pl("		this.${p.name} = val;");
				}
				setter.pl("}");
				
			addMethod(bean, setter.asMethodNodeSnippet(),model.options.isMarkGenerated());
		}
	}
	
	private void generateMapAddRemove(JType bean, BeanModel model,BeanPropertyModel property) {
		if(!property.isFromSuperClass() && property.getType().isKeyed() && model.options.isGenerateAddRemoveMethodsForIndexedProperties()){
			SourceTemplate add = ctxt
				.newSourceTemplate()
				.var("p.name", property.getPropertyName())
				.var("p.addName", property.getPropertyAddName())
				.var("p.type", property.getType().getObjectTypeFullName())
				.var("p.newType", property.getPropertyConcreteType())
				.var("p.genericPart", property.getType().getGenericPartOrEmpty())
				.var("p.keyType", property.getType().getIndexedKeyTypeNameOrNull())
				.var("p.valueType", property.getType().getIndexedValueTypeNameOrNull())
					
				.pl("public void ${p.addName}(final ${p.keyType} key,final ${p.valueType} val){");
			
			if(!property.isFinalField()){
				add.pl("	if(this.${p.name} == null){ this.${p.name} = new ${p.newType}${p.genericPart}(); }");
			}
			add
				.pl("	this.${p.name}.put(key, val);")
				.pl("}");
				
			addMethod(bean, add.asMethodNodeSnippet(),model.options.isMarkGenerated());
			
			SourceTemplate remove = ctxt
				.newSourceTemplate()
				.var("p.name", property.getPropertyName())
				.var("p.removeName", property.getPropertyRemoveName())
				.var("p.type", property.getType().getObjectTypeFullName())
				.var("p.newType", property.getPropertyConcreteType())
				.var("p.keyType", property.getType().getIndexedKeyTypeNameOrNull())
				
				.pl("public void ${p.removeName}(final ${p.keyType} key){")
				.pl("	if(this.${p.name} != null){ ")
				.pl("		this.${p.name}.remove(key);")
				.pl("	}")
				
				.pl("}");
				
			addMethod(bean, remove.asMethodNodeSnippet(),model.options.isMarkGenerated());
		}
	}

	private void generateCollectionAddRemove(JType bean, BeanModel model,BeanPropertyModel property) {
		if(!property.isFromSuperClass() && property.getType().isCollection() && model.options.isGenerateAddRemoveMethodsForIndexedProperties()){
		{
			if((property.isVetoable() || property.isBindable()) && !property.getType().isList()){
				throw new JMutateException("Property " + bean.getFullName() + "." + property.getPropertyName() + " is marked as vetoable or bindable and it's a collection. "
						+ "It must be a list, map, or not an indexed property (we must be able to get the index of the current element). Instead have a collection. "
						+ "Mark the property as not vetoable or bindable, or don't generate add/remove methods.");
			}
				SourceTemplate add = ctxt
					.newSourceTemplate()
					.var("p.name", property.getPropertyName())
					.var("p.addName", property.getPropertyAddName())
					.var("p.type", property.getType().getObjectTypeFullName())
					.var("p.newType", property.getPropertyConcreteType())
					.var("p.genericPart", property.getType().getGenericPartOrEmpty())
					.var("p.valueType", property.getType().getIndexedValueTypeNameOrNull())
					.var("support.bind.name", model.options.getPropertyChangeSupportFieldName())
					.var("support.veto.name", model.options.getVetoableChangeSupportFieldName())
					
					.p("public void ${p.addName}(final ${p.valueType} val)");
					if(property.isVetoable()){
						add.p(" throws java.beans.PropertyVetoException ");
					}
					add.pl("{");
						
					if(!property.isFinalField()){
						add
						.pl(" 	if(this.${p.name} == null){ ")
						.pl("		this.${p.name} = new ${p.newType}${p.genericPart}(); ")
						.pl("	}");	
					}
				
				CharSequence vetoString = "";
				
				if(property.isVetoable()){
					vetoString = add.child()
					.pl("   this.${support.veto.name}.fireIndexedVetoableChange(\"${p.name}\",this.${p.name}.size(),this.${p.name},val);")
					.interpolateTemplate();
				}
				if(property.isBindable()){
					add
						.pl("	${p.type} oldVal = this.${p.name};")
						.p(vetoString)
						.pl("	this.${p.name}.add(val);")
						.pl("   this.${support.bind.name}.fireIndexedPropertyChange(\"${p.name}\",this.${p.name}.size()-1,oldVal,val);");
				} else {
					add
						.p(vetoString)
						.pl("		this.${p.name}.add(val);");
				}
				add.pl("}");
					
				addMethod(bean, add.asMethodNodeSnippet(),model.options.isMarkGenerated());
			}
			{
				SourceTemplate remove = ctxt
					.newSourceTemplate()
					.var("p.name", property.getPropertyName())
					.var("p.removeName", property.getPropertyRemoveName())
					.var("p.type", property.getType().getObjectTypeFullName())
					.var("p.newType", property.getPropertyConcreteType())
					.var("p.valueType", property.getType().getIndexedValueTypeNameOrNull())
					.var("support.bind.name", model.options.getPropertyChangeSupportFieldName())
					.var("support.veto.name", model.options.getVetoableChangeSupportFieldName())
					
					.p("public void ${p.removeName}(final ${p.valueType} val)");
				
					if(property.isVetoable()){
						remove.p(" throws java.beans.PropertyVetoException ");
					}
					remove.pl("{");
					remove.pl("	if(this.${p.name} != null){ ");
				
				CharSequence vetoString = "";
				CharSequence indexString = "";
				if(property.isVetoable() || property.isBindable()){
					indexString = remove.child()
							.pl("int index = this.${p.name}.indexOf(val);")
							.pl("if( index < 0 ){ return; }")
							.interpolateTemplate();
				}
				if(property.isVetoable()){
					vetoString = remove.child()
					.pl("   this.${support.veto.name}.fireIndexedVetoableChange(\"${p.name}\",index,val,null);")
					.interpolateTemplate();
				}
				if(property.isBindable()){
					remove
						.p(indexString)
						.p(vetoString)
						.pl("	this.${p.name}.remove(val);")
						.pl("   this.${support.bind.name}.fireIndexedPropertyChange(\"${p.name}\",index,val,null);");
				} else {
					remove
						.p(indexString)
						.p(vetoString)
						.pl("	this.${p.name}.remove(val);");
				}
				remove.pl("	}");
				remove.pl("}");
				
				addMethod(bean, remove.asMethodNodeSnippet(),model.options.isMarkGenerated());
			}
		}
	}

	private void generateGetter(JType bean, BeanModel model, BeanPropertyModel property) {
		//getter
		if(!property.isFromSuperClass() && property.getPropertyGetterName() != null && property.isGenerateGetter()){
			SourceTemplate getter = ctxt
				.newSourceTemplate()
				.var("p.name", property.getPropertyName())
				.var("p.getterName", property.getPropertyGetterName())
				.var("p.type", property.getType().getObjectTypeFullName())
				
				.pl("public ${p.type} ${p.getterName}(){")
				.pl("		return ${p.name};")
				.pl("}");
				
			addMethod(bean, getter.asMethodNodeSnippet(),model.options.isMarkGenerated());
		}
	}
	
	//picks a repeatable but randomish prime for the given type
	private int pickStartingPrimeForClass(String fullName){			
		int hash = fullName.hashCode();
		int index;
		if(hash < 0){
			hash = -hash;
		}
		index = hash % FIRST_PRIMES.length;
		return FIRST_PRIMES[index];
	}

	private void addField(JType type, FieldDeclaration f, boolean markGenerated) {
		if(markGenerated){
			generatorMeta.addGeneratedMarkers(f);
		}
		ctxt.obtain(InsertFieldTransform.class)
				.clashStrategy(ClashStrategy.REPLACE)
				.target(type)
				.field(f)
				.transform();
		
	}
	
	private void addMethod(JType type, MethodDeclaration m, boolean markGenerated) {
		if(markGenerated){
			generatorMeta.addGeneratedMarkers(m);
		}
		ctxt.obtain(InsertMethodTransform.class)
				.clashStrategy(methodClashResolver)
				.target(type)
				.method(m)
				.transform();
	}

	private void writeToDiskIfChanged(JSourceFile source) {
		if (source != null) {
			cleanupImports(source.getAstNode());
			source = source.asMutator(ctxt).writeModificationsToDisk();
		}
	}

	private void cleanupImports(ASTNode node) {
		ctxt.obtain(CleanImportsTransform.class).addMissingImports(true)
				.nodeToClean(node).transform();
	}

	private class OnlyReplaceMyManagedMethodsResolver implements
			ClashStrategyResolver {

		private final ClashStrategy fallbackStrategy;

		public OnlyReplaceMyManagedMethodsResolver(
				ClashStrategy fallbackStrategy) {
			super();
			this.fallbackStrategy = fallbackStrategy;
		}

		@Override
		public ClashStrategy resolveClash(ASTNode existingNode, ASTNode newNode) {
			if (generatorMeta.isManagedByThis(JMethod.from(existingNode).getAnnotations())) {
				return ClashStrategy.REPLACE;
			}
			return fallbackStrategy;
		}

	}

}