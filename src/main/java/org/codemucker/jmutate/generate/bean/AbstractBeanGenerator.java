package org.codemucker.jmutate.generate.bean;

import java.lang.annotation.Annotation;

import org.apache.commons.configuration.Configuration;
import org.apache.log4j.LogManager;
import org.apache.log4j.Logger;
import org.codemucker.jmutate.ClashStrategyResolver;
import org.codemucker.jmutate.JMutateContext;
import org.codemucker.jmutate.SourceTemplate;
import org.codemucker.jmutate.ast.JSourceFile;
import org.codemucker.jmutate.ast.JType;
import org.codemucker.jmutate.generate.AbstractCodeGenerator;
import org.codemucker.jmutate.generate.CodeGenMetaGenerator;
import org.codemucker.jmutate.generate.ReplaceOnlyOwnedNodesResolver;
import org.codemucker.jmutate.generate.SmartConfig;
import org.codemucker.jmutate.generate.model.pojo.PojoModel;
import org.codemucker.jmutate.generate.model.pojo.PropertyModelExtractor;
import org.codemucker.jmutate.transform.CleanImportsTransform;
import org.codemucker.jmutate.transform.InsertFieldTransform;
import org.codemucker.jmutate.transform.InsertMethodTransform;
import org.codemucker.jpattern.generate.ClashStrategy;
import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.jdt.core.dom.FieldDeclaration;
import org.eclipse.jdt.core.dom.MethodDeclaration;

/**
 * 
 * @param <T> the annotation this generator is using for configuration
 * @param <TOptions> the options class this generator is mapping the annotation to. Property setters or fields must match those 
 * of the annotation. That is, foo() on the annotation is setFoo() on the options
 */
public abstract class AbstractBeanGenerator<T extends Annotation,TOptions extends AbstractBeanOptions<T>> extends AbstractCodeGenerator<T>  {

	private static final Logger LOG = LogManager.getLogger(AbstractBeanGenerator.class);

	private final CodeGenMetaGenerator generatorMeta;
	
	private final JMutateContext ctxt;
	
	private ClashStrategyResolver methodClashResolver;

	private Class<T> annotationType;
	
	protected abstract TOptions createOptionsFrom(Configuration config, JType type);
	protected abstract void generate(JType bean, SmartConfig config, PojoModel model,TOptions options);

	public AbstractBeanGenerator(JMutateContext ctxt, Class<T> annotationType) {
		this.ctxt = ctxt;
		this.generatorMeta = new CodeGenMetaGenerator(ctxt, getClass());
		this.annotationType = annotationType;
	}
	
	@Override
	public void beforeRun() {
		//TODO:find all artifacts generated by this generator
	}

	@Override
	public void afterRun() {
		//TODO:remove all artifacts belonging to this generator which were not regenerated
	}

	protected JMutateContext getCtxt(){
		return ctxt;
	}

	@Override
	public void generate(JType node, SmartConfig config) {
		TOptions options = createOptionsFrom(config.getConfigFor(annotationType),node);
		
		if(!options.isEnabled()){
			LOG.info("generator annotation marked as disabled, not running generation");
			return;
		}
		if(node.isInterface()){
			LOG.warn("the " + annotationType.getName() + " generation annotation on an interface is not supported");
			return;
		}

		PojoModel model = extractPropertiesModelFrom(node, options);
		ClashStrategy methodClashDefaultStrategy = options.getClashStrategy();
		methodClashResolver = new ReplaceOnlyOwnedNodesResolver(generatorMeta,methodClashDefaultStrategy);
		
		LOG.debug("found " + model.getAllProperties().toList().size() + " bean properties for "  + options.getType().getFullNameRaw());
		
		JSourceFile source = node.getCompilationUnit().getSource();
		generate(node, config, model, options);	
		writeToDiskIfChanged(source);	
	}
	
    private PojoModel extractPropertiesModelFrom(JType node, AbstractBeanOptions<?> options){
    	PropertyModelExtractor extractor = ctxt.obtain(PropertyModelExtractor.Builder.class)
    		.includeCompiledClasses(true)
    		.propertyNameMatching(options.getFieldNames())
    		.includeSuperClass(options.isInheritParentProperties())
    		.build();
    		
    	PojoModel pojo = extractor.extractModelFromClass(node);

    	return pojo;
    }
	

	protected void addField(JType type, FieldDeclaration f, boolean markGenerated) {
		if(markGenerated){
			generatorMeta.addGeneratedMarkers(f);
		}
		ctxt.obtain(InsertFieldTransform.class)
				.clashStrategy(ClashStrategy.REPLACE)
				.target(type)
				.field(f)
				.transform();
		
	}
	
	protected void addMethod(JType type, MethodDeclaration m, boolean markGenerated) {
		if(markGenerated){
			generatorMeta.addGeneratedMarkers(m);
		}
		ctxt.obtain(InsertMethodTransform.class)
				.clashStrategy(methodClashResolver)
				.target(type)
				.method(m)
				.transform();
		
	}

	private void writeToDiskIfChanged(JSourceFile source) {
		if (source != null) {
			cleanupImports(source.getAstNode());
			source = source.asMutator(ctxt).writeModificationsToDisk();
		}
	}

	protected void cleanupImports(ASTNode node) {
		ctxt.obtain(CleanImportsTransform.class).addMissingImports(true)
				.nodeToClean(node).transform();
	}
	
	protected SourceTemplate newSourceTemplate(){
		return ctxt
			.newSourceTemplate();
	}

}